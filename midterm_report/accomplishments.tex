\section{Accomplishments}

\subsection{M\"obius Simulation}

\subsubsection{Failure Model}

In order to perform an effective failure analysis of the IlliniSat boot and recovery system, we first had to develop an error model to describe it.

We consider the IlliniSat system failed if the system's Command and Data Handling (CD\&H) board is unable to resume normal operations after a fault occurs.  The satellite's health monitor already has support for a hardware watchdog timer; if the CD\&H board is unresponsive, it is assumed to have failed and it is rebooted \cite{jagannatha2014command}.  As such, the system is able to tolerate failure of the CD\&H system provided that the CD\&H board is able to boot the operating system and resume normal operation.  In this model, we consider the probability that this recovery process will not succeed due to corruption of the operating system's image in flash memory.

This error model has two primary components: failures in RAM and the CD\&H board's execution that force a system reboot and failures in flash memory that prevent this reboot from being successful.

% TODO: are SEU's transient?
We plan on modeling failures in flash memory as the interaction of two different cosmic ray-induced failures.  Single Event Upsets (SEUs) impact individual bits in memory and cannot be fixed without active error correction.  Single Event Functional Interrupt (SEFI) events occur when the logic circuitry for the memory is hit, impacting normal operation.  We use the description of SEFIs in \cite{Gerardin2010Present} to guide our model; we assume that the flash memory is unresponsive after an SEFI until the memory is power-cycled.

\subsubsection{M\"obius Baseline Model}

\subsection{Consistent Boot/Recovery Procedure}
The first challenge with this project was to get a working development
environment off the ground.  Installing QEMU was fairly straightforward, but
cross-compiling and getting u-boot and Linux to work took some effort.  We tried
a number of different ARM boards implemented in QEMU and eventually settled on
the ``versatilepb'' since it was the best documented.\footnote{http://balau82.wordpress.com/2010/03/10/u-boot-for-arm-on-qemu/}$^{,}$\footnote{http://elinux.org/Virtual\_Development\_Board}

After getting u-boot to work, we built a Linux kernel (version 3.2.67 was chosen
as IlliniSat is using a 3.2 based kernel) and booted that both with and without 
u-boot.  To demonstrate that the OS is working properly, we tried to get a
regular user process to run (by specifying it as the \fix{init} process).
However, this was highly non-trivial since it depended on things like system
call linkage, a working libc, and a filesystem.  Since the main project involves
the boot procedure, we will just boot the Linux kernel and let it panic by not
finding an init process. We intend to fix this for a proper demonstration in the
future.

It was discovered the u-boot has a built-in CRC-32 command, which we plan to
utilize. U-boot has two main ways of adding code: via scripts and standalone
applications.  After discovering to enable scripts (by modifying the
configuration header file), we have have decided to use the script method as
that is the most portable option. We have demonstrated the ability to get a
working test script that modifies the u-boot environment and next we will work
on building the boot-assurance script.  


\subsection{Flash Patrol Read Daemon}

